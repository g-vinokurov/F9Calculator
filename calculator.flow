// flowcpp task.flow -- key1=val1 key2=val2

import runtime;
import string;
import string_utils;
import ds/dlist;
import ds/tuples;
import math/math;

import lingo/pegcode/driver;

Exp ::= Err, Int, Var, Operator;
Err(msg : string);
Int(i : int);
Var(v : string);
Operator ::= Pass, UnaryOperator, BinaryOperator;
Pass();
UnaryOperator ::= Neg, Ln;
Neg(e : Exp);
Ln(e : Exp);
BinaryOperator ::= Add, Sub, Mul, Div, Pow;
Add(eR : Exp, eL : Exp);
Sub(eR : Exp, eL : Exp);
Mul(eR : Exp, eL : Exp);
Div(eR : Exp, eL : Exp);
Pow(eR : Exp, eL : Exp);


PostfixToken ::= PostfixErr, PostfixInt, PostfixVar, PostfixOperator;
PostfixErr(msg : string);
PostfixInt(s : string);
PostfixVar(v : string);
PostfixOperator ::= PostfixPass, PostfixUnaryOperator, PostfixBinaryOperator;
PostfixPass();
PostfixUnaryOperator ::= PostfixNeg, PostfixLn;
PostfixNeg();
PostfixLn();
PostfixBinaryOperator ::= PostfixAdd, PostfixSub, PostfixMul, PostfixDiv, PostfixPow;
PostfixAdd();
PostfixSub();
PostfixMul();
PostfixDiv();
PostfixPow();

PostfixTokens(head : PostfixToken, tail : [PostfixToken]);


InfixToken ::= InfixErr, InfixInt, InfixVar, InfixOperator;
InfixErr(msg : string);
InfixInt(s : string);
InfixVar(v : string);
InfixOperator ::= InfixPass, InfixParenthesis, InfixUnaryOperator, InfixBinaryOperator;
InfixPass();
InfixParenthesis ::= InfixOpeningParenthesis, InfixClosingParenthesis;
InfixOpeningParenthesis();
InfixClosingParenthesis();
InfixUnaryOperator ::= InfixNeg, InfixLn; 
InfixNeg();
InfixLn();
InfixBinaryOperator ::= InfixAdd, InfixSub, InfixMul, InfixDiv, InfixPow;
InfixAdd();
InfixSub();
InfixMul();
InfixDiv();
InfixPow();

InfixTokens(ts : [InfixToken]);

sI(intAsExp : Exp) -> int {
    if (isNegConst(intAsExp)) {
        sI(sE(intAsExp));
    } else switch (intAsExp : Exp) {
        Int(i) : i;
        default : 0;
    }
}

// subexpression
sE(e : Exp) -> Exp { 
    switch(e : Exp) { 
        Neg(eN) : eN;
        Ln(eL) : eL; 
        default : Pass(); 
    } 
}

// Left subexpression 
sL(e : Exp) -> Exp { 
    switch(e : Exp) {
        Add(eR, eL) : eL;
        Sub(eR, eL) : eL;
        Mul(eR, eL) : eL;
        Div(eR, eL) : eL;
        Pow(eR, eL) : eL;
        default : Pass(); 
    }
}

// Right subexpression 
sR(e : Exp) -> Exp { 
    switch(e : Exp) {
        Add(eR, eL) : eR;
        Sub(eR, eL) : eR;
        Mul(eR, eL) : eR;
        Div(eR, eL) : eR;
        Pow(eR, eL) : eR;
        default : Pass(); 
    }
}

isPosConst(e : Exp) -> bool { switch (e : Exp) { Int(i) : (i > 0); default : false; } }
isNegConst(e : Exp) -> bool { isNeg(e) && isPosConst(sE(e)); }
isZero(e : Exp) -> bool { e == Int(0); }
isConst(e : Exp) -> bool { isNegConst(e) || isZero(e) || isPosConst(e); }
isVar(e : Exp) -> bool { switch (e : Exp) { Var(v) : true; default : false; } }
isNeg(e : Exp) -> bool { switch (e : Exp) { Neg(eN) : true; default : false; } }
isLn(e : Exp) -> bool { switch (e : Exp) { Ln(eL) : true; default : false; } }
isAdd(e : Exp) -> bool { switch (e : Exp) { Add(eR, eL) : true; default : false; } }
isSub(e : Exp) -> bool { switch (e : Exp) { Sub(eR, eL) : true; default : false; } }
isMul(e : Exp) -> bool { switch (e : Exp) { Mul(eR, eL) : true; default : false; } }
isDiv(e : Exp) -> bool { switch (e : Exp) { Div(eR, eL) : true; default : false; } }
isPow(e : Exp) -> bool { switch (e : Exp) { Pow(eR, eL) : true; default : false; } }

modInt(eL : Exp, eR : Exp) -> int { mod(sI(eL), sI(eR)); }

isUnaryOperator(e : Exp) -> bool { isNeg(e) || isLn(e); }
isBinaryOperator(e : Exp) -> bool { isAdd(e) || isSub(e) || isMul(e) || isDiv(e) || isPow(e); }

popExp(dlist : DList<Exp>) -> Exp {
    either(popDList(dlist), Err("Stack is empty"));
}

pushExp(dlist : DList<Exp>, val : Exp) -> DLink<Exp> {
    pushDList(dlist, val);
}

infixTokenToPostfixToken(iT : InfixToken) -> PostfixToken {
    switch (iT : InfixToken) {
        InfixErr(msg) : PostfixErr(msg);
        InfixInt(s) : PostfixInt(s);
        InfixVar(v) : PostfixVar(v);
        InfixPass() : PostfixPass();
        InfixNeg() : PostfixNeg();
        InfixLn() : PostfixLn();
        InfixAdd() : PostfixAdd();
        InfixSub() : PostfixSub();
        InfixMul() : PostfixMul();
        InfixDiv() : PostfixDiv();
        InfixPow() : PostfixPow();
        default : PostfixErr("Couldn't convert infix token to postfix token");
    }
}

getInfixOperatorPriority(operator : InfixOperator) -> int {
    switch (operator : InfixOperator) {
        InfixPass() : -1;
        InfixOpeningParenthesis() : 0;
        InfixClosingParenthesis() : 0;
        InfixNeg() : 10;
        InfixLn() : 10;
        InfixAdd() : 1;
        InfixSub() : 1;
        InfixMul() : 2;
        InfixDiv() : 2;
        InfixPow() : 3;
    }
}

infixTokenToInfixOperator(token : InfixToken) -> InfixOperator {
    switch (token : InfixToken) {
        InfixOpeningParenthesis() : token;
        InfixClosingParenthesis() : token;
        InfixAdd() : token;
        InfixSub() : token;
        InfixMul() : token;
        InfixDiv() : token;
        InfixPow() : token;
        InfixNeg() : token;
        InfixLn() : token;
        default : InfixPass();
    }
}

processNoLessPriorityOperator(stackItem : InfixOperator, op : InfixOperator, stack : DList<InfixOperator>, out : DList<PostfixToken>) -> InfixOperator {
    res : bool = (getInfixOperatorPriority(stackItem) >= getInfixOperatorPriority(op));
    if (res) {
        pushDList(out, infixTokenToPostfixToken(stackItem));
        processNoLessPriorityOperators(op, stack, out);
    } else {
        pushDList(stack, stackItem);
        pushDList(stack, op);
        stackItem;
    }
}

processBetweenParenthesisOperator(stackItem : InfixOperator, stack : DList<InfixOperator>, out : DList<PostfixToken>) -> bool {
    pushDList(out, infixTokenToPostfixToken(stackItem));
    processBetweenParenthesisOperators(stack, out);
}

processNoLessPriorityOperators(op : InfixOperator, stack : DList<InfixOperator>, out : DList<PostfixToken>) -> InfixOperator {
    if (isEmptyDList(stack) == true) {
        pushDList(stack, op);
        op;
    } else {
        stackItem = either(popDList(stack), InfixPass());
        switch (stackItem : InfixOperator) {
            InfixPass() : stackItem;
            InfixClosingParenthesis() : stackItem;
            default : processNoLessPriorityOperator(stackItem, op, stack, out);
        }
    }
}

processBetweenParenthesisOperators(stack : DList<InfixOperator>, out : DList<PostfixToken>) -> bool {
    if (isEmptyDList(stack) == true) {
        pushDList(out, PostfixErr("There is no opening parenthesis"));
        false;
    } else {
        stackItem = either(popDList(stack), InfixPass());
        switch (stackItem : InfixOperator) {
            InfixPass() : false;
            InfixClosingParenthesis() : false;
            InfixOpeningParenthesis() : true;
            default : processBetweenParenthesisOperator(stackItem, stack, out) && true;
        }
    }
}

shuntingYard(infixTokens : [InfixToken]) -> [PostfixToken] {
    stack : DList<InfixOperator> = makeDList();
    out : DList<PostfixToken> = fold(infixTokens, makeDList(), \acc,x -> {
        switch (x : InfixToken) {
            InfixInt(i) : { pushDList(acc, PostfixInt(i)); x; }
            InfixVar(v) : { pushDList(acc, PostfixVar(v)); x; }
            InfixErr(msg) : x;
            InfixPass() : x;
            InfixOpeningParenthesis() : { pushDList(stack, x); x; }
            InfixClosingParenthesis() : { processBetweenParenthesisOperators(stack, acc); x; }
            default : { processNoLessPriorityOperators(infixTokenToInfixOperator(x), stack, acc); x; }
        }
        acc;
    });

    completed_out : DList<PostfixToken> = rfoldDList(stack, out, \acc,x -> {
        switch (x : InfixOperator) {
            InfixOpeningParenthesis() : pushDList(acc, PostfixErr("The parenthesis was missed"));
            default : pushDList(acc, infixTokenToPostfixToken(x));
        }
        acc;
    });

    dList2array(completed_out);
}

postfixTokenizerGr = "
    exp = ws* operand:o token*:ts ws* { PostfixTokens(:o, :ts) };

    token = ws+ (operand | operator):t { :t };

    operator = (addOp | subOp | mulOp | divOp | powOp | negOp | lnOp):o { :o };
    addOp = '+'$op { PostfixAdd() };
    subOp = '-'$op { PostfixSub() };
    mulOp = '*'$op { PostfixMul() };
    divOp = '/'$op { PostfixDiv() };
    powOp = '^'$op { PostfixPow() };
    negOp = '~'$op { PostfixNeg() };
    lnOp = '#Ln'$op { PostfixLn() };

    operand = (int | variable):o { :o };

    variable = (letter+ (digit | letter)*)$v { PostfixVar($v) };
    int = digit+$i { PostfixInt($i) };

    letter = ('A'-'Z') | ('a'-'z') | '_';
    digit = '0'-'9';
    ws = (' ' | '\t');
";

infixTokenizerGr = "
    exp = ws* token*:ts ws* { InfixTokens(:ts) };

    token = ws* (int | variable | operator | parenthesis):t ws* { :t };

    parenthesis = (closingParenthesis | openingParenthesis):p { :p };
    openingParenthesis = '('$p { InfixOpeningParenthesis() };
    closingParenthesis = ')'$p { InfixClosingParenthesis() };

    operator = (addOp | subOp | mulOp | divOp | powOp | negOp | lnOp):o { :o };
    addOp = '+'$op { InfixAdd() };
    subOp = '-'$op { InfixSub() };
    mulOp = '*'$op { InfixMul() };
    divOp = '/'$op { InfixDiv() };
    powOp = '^'$op { InfixPow() };
    negOp = '~'$op { InfixNeg() };
    lnOp = '#Ln'$op { InfixLn() };

    variable = (letter+ (digit | letter)*)$v { InfixVar($v) };
    int = digit+$i { InfixInt($i) };

    letter = ('A'-'Z') | ('a'-'z') | '_';
    digit = '0'-'9';
    ws = (' ' | '\t');
";

compiledPostfixTokenizerGr = compilePegGrammar(postfixTokenizerGr);
compiledInfixTokenizerGr = compilePegGrammar(infixTokenizerGr);

tokenizePostfix(exprStr : string) -> [PostfixToken] {
    parsed = parsic(compiledPostfixTokenizerGr, exprStr, defaultPegActions);
    concat([parsed.head], parsed.tail);
}

tokenizeInfix(exprStr : string) -> [InfixToken] {
    parsed = parsic(compiledInfixTokenizerGr, exprStr, defaultPegActions);
    parsed.ts;
}

verifyAst(ast : Exp) -> bool {
    if (isBinaryOperator(ast)) { 
        verifyAst(sR(ast)) && verifyAst(sL(ast));
    } else if (isUnaryOperator(ast)) { 
        verifyAst(sE(ast)); 
    } else if (ast == Pass() || isConst(ast) || isVar(ast)) { 
        true; 
    } else {
        false; 
    }
}

postfixTokensToAst(postfixTokens : [PostfixToken]) -> Exp {
    stack : DList<Exp> = fold(postfixTokens, makeDList(), \acc,x -> {
        switch (x : PostfixToken) {
            PostfixAdd() : pushExp(acc, Add(popExp(acc), popExp(acc)));
            PostfixSub() : pushExp(acc, Sub(popExp(acc), popExp(acc)));
            PostfixMul() : pushExp(acc, Mul(popExp(acc), popExp(acc)));
            PostfixDiv() : pushExp(acc, Div(popExp(acc), popExp(acc)));
            PostfixPow() : pushExp(acc, Pow(popExp(acc), popExp(acc)));
            PostfixNeg() : pushExp(acc, Neg(popExp(acc)));
            PostfixLn() : pushExp(acc, Ln(popExp(acc)));
            PostfixPass() : pushExp(acc, popExp(acc));
            PostfixVar(v) : pushExp(acc, Var(v));
            PostfixInt(i) : pushExp(acc, Int(s2i(i)));
            PostfixErr(msg) : pushExp(acc, Err(msg));
        }
        acc;
    });
    ast = popExp(stack);
    if (verifyAst(ast)) {
        ast;
    } else {
        Err("AST is wrong");
    }
}

postfixToAst(exprStr : string) -> Exp {
    postfixTokensToAst(tokenizePostfix(exprStr));
}

astToPostfix(verifiedAst : Exp) -> string {
    switch(verifiedAst : Exp) {
        Add(eR, eL) : astToPostfix(eL) + astToPostfix(eR) + " +";
        Sub(eR, eL) : astToPostfix(eL) + astToPostfix(eR) + " -";
        Mul(eR, eL) : astToPostfix(eL) + astToPostfix(eR) + " *";
        Div(eR, eL) : astToPostfix(eL) + astToPostfix(eR) + " /";
        Pow(eR, eL) : astToPostfix(eL) + astToPostfix(eR) + " ^";
        Neg(e) : astToPostfix(e) + " ~";
        Ln(e) : astToPostfix(e) + " #Ln";
        Int(i) : " " + i2s(i);
        Var(v) : " " + v;
        default : "";
    }
}

infixToAst(exprStr : string) -> Exp {
    postfixTokensToAst(shuntingYard(tokenizeInfix(exprStr)));
}

astToInfix(verifiedAst : Exp) -> string {
    switch (verifiedAst : Exp) {
        Add(eR, eL) : "(" + astToInfix(eL) + "+" + astToInfix(eR) + ")";
        Sub(eR, eL) : "(" + astToInfix(eL) + "-" + astToInfix(eR) + ")";
        Mul(eR, eL) : "(" + astToInfix(eL) + "*" + astToInfix(eR) + ")";
        Div(eR, eL) : "(" + astToInfix(eL) + "/" + astToInfix(eR) + ")";
        Pow(eR, eL) : "(" + astToInfix(eL) + "^" + astToInfix(eR) + ")";
        Neg(e) : "~(" + astToInfix(e) + ")";
        Ln(e) : "#Ln(" + astToInfix(e) + ")";
        Var(v) : v;
        Int(i) : i2s(i);
        default : "";
    }
}

substituteVarsToAst(verifiedAst : Exp, vars : Tree<string, int>) -> Exp {
    switch (verifiedAst : Exp) {
        Var(v) : { 
            value = lookupTree(vars, v);
            if (value == None()) {
                Var(v);
            } else {
                simplifyInt(either(value, 0));
            }
        };
        Add(eR, eL) : Add(substituteVarsToAst(eR, vars), substituteVarsToAst(eL, vars));
        Sub(eR, eL) : Sub(substituteVarsToAst(eR, vars), substituteVarsToAst(eL, vars));
        Mul(eR, eL) : Mul(substituteVarsToAst(eR, vars), substituteVarsToAst(eL, vars));
        Div(eR, eL) : Div(substituteVarsToAst(eR, vars), substituteVarsToAst(eL, vars));
        Pow(eR, eL) : Pow(substituteVarsToAst(eR, vars), substituteVarsToAst(eL, vars));
        Neg(e) : Neg(substituteVarsToAst(e, vars));
        Ln(e) : Ln(substituteVarsToAst(e, vars));
        Int(i) : Int(i);
        default : verifiedAst;
    }
}

astHasUnsubstitutedVars(verifiedAst : Exp) -> bool {
    switch (verifiedAst : Exp) {
        Var(v) : true;
        Add(eR, eL) : astHasUnsubstitutedVars(eR) || astHasUnsubstitutedVars(eL);
        Sub(eR, eL) : astHasUnsubstitutedVars(eR) || astHasUnsubstitutedVars(eL);
        Mul(eR, eL) : astHasUnsubstitutedVars(eR) || astHasUnsubstitutedVars(eL);
        Div(eR, eL) : astHasUnsubstitutedVars(eR) || astHasUnsubstitutedVars(eL);
        Pow(eR, eL) : astHasUnsubstitutedVars(eR) || astHasUnsubstitutedVars(eL);
        Neg(e) : astHasUnsubstitutedVars(e);
        Ln(e) : astHasUnsubstitutedVars(e);
        Pass() : false;
        Int(i) : false;
        default : true;
    }
}

calculateAst(verifiedAst : Exp) -> int {
    switch (verifiedAst : Exp) {
        Add(eR, eL) : calculateAst(eL) + calculateAst(eR);
        Sub(eR, eL) : calculateAst(eL) - calculateAst(eR);
        Mul(eR, eL) : calculateAst(eL) * calculateAst(eR);
        Div(eR, eL) : calculateAst(eL) / calculateAst(eR);
        Pow(eR, eL) : pow(calculateAst(eL), calculateAst(eR));
        Neg(e) : (-1) * calculateAst(e);
        Ln(e) : floor(log(i2d(calculateAst(e))));
        Int(i) : i;
        default : 0;
    }
}

calculateAstWithVars(verifiedAst : Exp, vars : Tree<string, int>) -> Exp {
    ast = substituteVarsToAst(verifiedAst, vars);
    if (astHasUnsubstitutedVars(ast)) {
        ast;
    } else {
        Int(calculateAst(ast));
    }
}

diffAdd(eR : Exp, eL : Exp, var : string) -> Exp {
    Add(diffAst(eR, var), diffAst(eL, var));
}

diffSub(eR : Exp, eL : Exp, var : string) -> Exp {
    Sub(diffAst(eR, var), diffAst(eL, var));
}

diffMul(eR : Exp, eL : Exp, var : string) -> Exp {
    Add(Mul(eL, diffAst(eR, var)), Mul(diffAst(eL, var), eR));
}

diffDiv(eR : Exp, eL : Exp, var : string) -> Exp {
    Div(Pow(Int(2), eR), Sub(Mul(eL, diffAst(eR, var)), Mul(diffAst(eL, var), eR)));
}

diffPow(eR : Exp, eL : Exp, var : string) -> Exp {
    switch (eR : Exp) {
        Int(i) : Mul(diffAst(eL, var), Mul(Pow(simplifyInt(i - 1), eL), eR)); 
        default : Mul(Add(Mul(diffAst(eL, var), Div(eL, eR)), Mul(Ln(eL), diffAst(eR, var))), Pow(eR, eL));
    }
}

diffNeg(e : Exp, var : string) -> Exp {
    Neg(diffAst(e, var));
}

diffLn(e : Exp, var : string) -> Exp {
    Mul(diffAst(e, var), Div(e, Int(1)));
}

diffAst(verifiedAst : Exp, var : string) -> Exp {
    switch (verifiedAst : Exp) {
        Add(eR, eL) : diffAdd(eR, eL, var);
        Sub(eR, eL) : diffSub(eR, eL, var);
        Mul(eR, eL) : diffMul(eR, eL, var);
        Div(eR, eL) : diffDiv(eR, eL, var);
        Pow(eR, eL) : diffPow(eR, eL, var);
        Neg(e) : diffNeg(e, var);
        Ln(e) : diffLn(e, var);
        Var(v) : if (v == var) { Int(1); } else { Int(0); };
        Int(i) : Int(0);
        default : Err("Not realised");
    }
}

simplifyInt(i : int) -> Exp {
    if (i < 0) { Neg(Int(-i)); } else { Int(i); }
}

simplifyNeg(e : Exp) -> Exp {
    ast = Neg(simplifyAst(e));
    switch (ast.e : Exp) {
        Int(i) : if (i == 0) { Int(0); } else { ast; }
        Neg(eE) : eE;
        default : ast;
    }
}

simplifyAdd(eRight : Exp, eLeft : Exp) -> Exp {
    ast = Add(simplifyAst(eRight), simplifyAst(eLeft));
    eR = ast.eR;
    eL = ast.eL;
    if (eR == Neg(eL) || eL == Neg(eR)) { Int(0); }
    else if (eR == Int(0)) { eL; }
    else if (eL == Int(0)) { eR; }
    else if (isConst(eL) && isConst(eR)) { simplifyInt(calculateAst(ast)); }
    else if (isNeg(eL) && isNeg(eR)) { simplifyAst(Neg(Add(sE(eR), sE(eL)))); }
    else if (isNeg(eL)) { simplifyAst(Sub(sE(eL), eR)); }
    else if (isNeg(eR)) { simplifyAst(Sub(sE(eR), eL)); }
    else ast;
}

simplifySub(eRight : Exp, eLeft : Exp) -> Exp {
    ast = Sub(simplifyAst(eRight), simplifyAst(eLeft));
    eR = ast.eR;
    eL = ast.eL;
    if (eR == Int(0)) { eL; } 
    else if (eL == Int(0)) { simplifyAst(Neg(eR)); }
    else if (eL == eR) { Int(0); }
    else if (isConst(eL) && isConst(eR)) { simplifyInt(calculateAst(ast)); }
    else if (isNeg(eL) && isNeg(eR)) { simplifyAst(Neg(Sub(sE(eR), sE(eL)))); }
    else if (isNeg(eL)) { simplifyAst(Neg(Add(eR, sE(eL)))); }
    else if (isNeg(eR)) { simplifyAst(Add(sE(eR), eL)); }
    else ast;
}

simplifyDiv(eRight : Exp, eLeft : Exp) -> Exp {
    ast = Div(simplifyAst(eRight), simplifyAst(eLeft));
    eR = ast.eR;
    eL = ast.eL;
    if (eL == Int(0)) { Int(0); }
    else if (eR == Int(1)) { eL; } 
    else if (eL == eR && eR != Int(0)) { Int(1); }
    else if (isConst(eL) && isConst(eR) && modInt(eL, eR) == 0) { simplifyInt(calculateAst(ast)); }
    else if (eL == Int(1) && isDiv(eR)) { simplifyAst(Div(sL(eR), sR(eR))); }
    else if (isNeg(eL) && isNeg(eR)) { simplifyAst(Div(sE(eR), sE(eL))); }
    else if (isNeg(eL)) { simplifyAst(Neg(Div(eR, sE(eL)))); }
    else if (isNeg(eR)) { simplifyAst(Neg(Div(sE(eR), eL))); }
    else if (isPow(eL) && isPow(eR) && sL(eL) == sL(eR)) { simplifyAst(Pow(Sub(sR(eR), sR(eL)), sL(eL))); }
    else if (isPow(eL) && sL(eL) == eR) { simplifyAst(Pow(Sub(Int(1), sR(eL)), eR)); }
    else if (isPow(eR) && eL == sL(eR)) { simplifyAst(Pow(Sub(sR(eR), Int(1)), eL)); }
    else ast;
}

simplifyMul(eRight : Exp, eLeft : Exp) -> Exp {
    ast = Mul(simplifyAst(eRight), simplifyAst(eLeft));
    eR = ast.eR;
    eL = ast.eL;
    if (eR == Int(0) || eL == Int(0)) { Int(0); }
    else if (eR == Int(1)) { eL; } 
    else if (eL == Int(1)) { eR; }
    else if (isConst(eL) && isConst(eR)) { simplifyInt(calculateAst(ast)); }
    else if (eR == Div(eL, Int(1))) { Int(1); }
    else if (eL == Div(eR, Int(1))) { Int(1); }
    else if (isNeg(eL) && isNeg(eR)) { simplifyAst(Mul(sE(eR), sE(eL))); }
    else if (isNeg(eL)) { simplifyAst(Neg(Mul(eR, sE(eL)))); }
    else if (isNeg(eR)) { simplifyAst(Neg(Mul(sE(eR), eL))); }
    else if (eL == eR) { simplifyAst(Pow(Int(2), eL)); }
    else if (isPow(eL) && isPow(eR) && sL(eL) == sL(eR)) { simplifyAst(Pow(Add(sR(eR), sR(eL)), sL(eL))); }
    else if (isPow(eL) && sL(eL) == eR) { simplifyAst(Pow(Add(Int(1), sR(eL)), eR)); }
    else if (isPow(eR) && eL == sL(eR)) { simplifyAst(Pow(Add(sR(eR), Int(1)), eL)); }
    else ast;
}

simplifyPow(eRight : Exp, eLeft : Exp) -> Exp {
    ast = Pow(simplifyAst(eRight), simplifyAst(eLeft));
    eR = ast.eR;
    eL = ast.eL;
    if (eR == Int(0)) { Int(1); }
    else if (eR == Int(1)) { eL; }
    else if (isConst(eL) && isConst(eR)) { simplifyInt(calculateAst(ast)); }
    else if (isNeg(eL) && isConst(eR) && modInt(eR, Int(2)) == 0) { simplifyAst(Pow(eR, sE(eL))); }
    else if (isNeg(eL) && isConst(eR) && modInt(eR, Int(2)) != 0) { simplifyAst(Neg(Pow(eR, sE(eL)))); }
    else ast;
}

simplifyAst(verifiedAst : Exp) -> Exp {
    switch (verifiedAst : Exp) {
        Add(eR, eL) : simplifyAdd(eR, eL);
        Sub(eR, eL) : simplifySub(eR, eL);
        Mul(eR, eL) : simplifyMul(eR, eL);
        Div(eR, eL) : simplifyDiv(eR, eL);
        Neg(e) : simplifyNeg(e);
        Pow(eR, eL) : simplifyPow(eR, eL);
        Int(i) : simplifyInt(i);
        default : verifiedAst;
    }
}

getAllUrlParametersAsTree() -> Tree<string, string> {
    fold(getAllUrlParametersArray(), makeTree(), \acc,x -> { setTree(acc, x[0], x[1]); });
}

getVars(parameters : Tree<string, string>) -> Tree<string, int> {
    varsValues = filterTree(parameters, \k,v -> k != "expr" && k != "result");
    foldTree(varsValues, makeTree(), \k,v,acc -> { setTree(acc, k, s2i(v)); });
}

testSimplifier() {
    tests : [Pair<Pair<string, string>, Exp>] = [
        Pair(Pair("Test-1.1", "x + 0"), Var("x")),
        Pair(Pair("Test-1.2", "0 + x"), Var("x")),
        Pair(Pair("Test-1.3", "~x + x"), Int(0)),
        Pair(Pair("Test-1.4", "x + (~x)"), Int(0)),
        Pair(Pair("Test-1.5", "5 + 4 + 3 + 2 + 1"), Int(15)),
        Pair(Pair("Test-1.6", "(5 + 4) * x"), Mul(Var("x"), Int(9))),
        Pair(Pair("Test-1.7", "5 + 4"), Int(9)),
        Pair(Pair("Test-1.8", "~5 + 4"), Neg(Int(1))),
        Pair(Pair("Test-1.9", "2 + (~4)"), Neg(Int(2))),
        Pair(Pair("Test-1.10", "~2 + (~4)"), Neg(Int(6))),
        Pair(Pair("Test-1.11", "~5 + 4 + (~6 + (~3))"), Neg(Int(10))),
        Pair(Pair("Test-1.12", "(~5 + 4 + (~6 + (~3))) * x"), Neg(Mul(Var("x"), Int(10)))),
        Pair(Pair("Test-1.13", "~x + (~y)"), Neg(Add(Var("y"), Var("x")))),
        Pair(Pair("Test-1.14", "~x + y"), Sub(Var("x"), Var("y"))),
        Pair(Pair("Test-1.15", "x + (~y)"), Sub(Var("y"), Var("x"))),

        Pair(Pair("Test-2.1", "x - 0"), Var("x")),
        Pair(Pair("Test-2.2", "0 - x"), Neg(Var("x"))),
        Pair(Pair("Test-2.3", "x - x"), Int(0)),
        Pair(Pair("Test-2.4", "5 - 4"), Int(1)),
        Pair(Pair("Test-2.5", "~5 - 4"), Neg(Int(9))),
        Pair(Pair("Test-2.6", "2 - (~4)"), Int(6)),
        Pair(Pair("Test-2.7", "~5 - (~4)"), Neg(Int(1))),
        Pair(Pair("Test-2.8", "~5 - 4 - (~6 - (~3))"), Neg(Int(6))),
        Pair(Pair("Test-2.9", "(~5 - 4 - (~6 - (~3))) * x"), Neg(Mul(Var("x"), Int(6)))),
        Pair(Pair("Test-2.10", "~x - (~y)"), Neg(Sub(Var("y"), Var("x")))),
        Pair(Pair("Test-2.11", "~x - y"), Neg(Add(Var("y"), Var("x")))),
        Pair(Pair("Test-2.12", "x - (~y)"), Add(Var("y"), Var("x"))),

        Pair(Pair("Test-3.1", "0 / x"), Int(0)),
        Pair(Pair("Test-3.2", "x / 1"), Var("x")),
        Pair(Pair("Test-3.3", "x / (~1)"), Neg(Var("x"))),
        Pair(Pair("Test-3.4", "x / x"), Int(1)),
        Pair(Pair("Test-3.5", "~x / x"), Neg(Int(1))),
        Pair(Pair("Test-3.6", "x / (~x)"), Neg(Int(1))),
        Pair(Pair("Test-3.7", "1 / (1 / x)"), Var("x")),
        Pair(Pair("Test-3.8", "1 / (~1 / x)"), Neg(Var("x"))),
        Pair(Pair("Test-3.9", "~1 / (1 / x)"), Neg(Var("x"))),
        Pair(Pair("Test-3.10", "~1 / (~1 / x)"), Var("x")),
        Pair(Pair("Test-3.11", "4 / 2"), Int(2)),
        Pair(Pair("Test-3.12", "4 / (~2)"), Neg(Int(2))),
        Pair(Pair("Test-3.13", "~4 / 2"), Neg(Int(2))),
        Pair(Pair("Test-3.14", "~4 / (~2)"), Int(2)),
        Pair(Pair("Test-3.15", "4 / 3"), Div(Int(3), Int(4))),
        Pair(Pair("Test-3.16", "(x ^ y) / (x ^ z)"), Pow(Sub(Var("z"), Var("y")), Var("x"))),
        Pair(Pair("Test-3.17", "(x ^ y) / x"), Pow(Sub(Int(1), Var("y")), Var("x"))),
        Pair(Pair("Test-3.18", "x / (x ^ y)"), Pow(Sub(Var("y"), Int(1)), Var("x"))),

        Pair(Pair("Test-4.1", "x * 0"), Int(0)),
        Pair(Pair("Test-4.2", "0 * x"), Int(0)),
        Pair(Pair("Test-4.3", "1 * x"), Var("x")),
        Pair(Pair("Test-4.4", "x * 1"), Var("x")),
        Pair(Pair("Test-4.5", "x * (~1)"), Neg(Var("x"))),
        Pair(Pair("Test-4.6", "~1 * x"), Neg(Var("x"))),
        Pair(Pair("Test-4.7", "x * 1 / x"), Int(1)),
        Pair(Pair("Test-4.8", "1 / x * x"), Int(1)),
        Pair(Pair("Test-4.9", "x * (~1) / x"), Neg(Int(1))),
        Pair(Pair("Test-4.10", "(~1) / x * x"), Neg(Int(1))),
        Pair(Pair("Test-4.11", "5 * 4"), Int(20)),
        Pair(Pair("Test-4.12", "~5 * 4"), Neg(Int(20))),
        Pair(Pair("Test-4.13", "2 * (~4)"), Neg(Int(8))),
        Pair(Pair("Test-4.14", "~5 * (~4)"), Int(20)),
        Pair(Pair("Test-4.15", "~5 * 4 * (~6 * (~3))"), Neg(Int(360))),
        Pair(Pair("Test-4.16", "(~5 * 4 * (~6 * (~3))) * x"), Neg(Mul(Var("x"), Int(360)))),
        Pair(Pair("Test-4.17", "x * x"), Pow(Int(2), Var("x"))),
        Pair(Pair("Test-4.18", "x * (~x)"), Neg(Pow(Int(2), Var("x")))),
        Pair(Pair("Test-4.19", "~x * x"), Neg(Pow(Int(2), Var("x")))),
        Pair(Pair("Test-4.20", "~x * (~x)"), Pow(Int(2), Var("x"))),
        Pair(Pair("Test-4.21", "(x ^ y) * (x ^ z)"), Pow(Add(Var("z"), Var("y")), Var("x"))),
        Pair(Pair("Test-4.22", "(x ^ y) * x"), Pow(Add(Int(1), Var("y")), Var("x"))),
        Pair(Pair("Test-4.23", "x * (x ^ y)"), Pow(Add(Var("y"), Int(1)), Var("x"))),

        Pair(Pair("Test-5.1", "~1"), Neg(Int(1))),
        Pair(Pair("Test-5.2", "~(~1)"), Int(1)),
        Pair(Pair("Test-5.3", "~0"), Int(0)),
        
        Pair(Pair("Test-6.1", "x ^ 0"), Int(1)),
        Pair(Pair("Test-6.2", "(x + 0) ^ 1"), Var("x")),
        Pair(Pair("Test-6.3", "~x ^ 4"), Pow(Int(4), Var("x"))),
        Pair(Pair("Test-6.4", "~x ^ 5"), Neg(Pow(Int(5), Var("x")))),
        Pair(Pair("Test-6.5", "~x ^ ~4"), Pow(Neg(Int(4)), Var("x"))),
        Pair(Pair("Test-6.6", "~x ^ ~5"), Neg(Pow(Neg(Int(5)), Var("x")))),
    ];

    map(tests, \i -> {
        result = simplifyAst(infixToAst(i.first.second)) == i.second;
        println("Simplifier: " + i.first.first + ": " + if (result) { "PASSED"; } else { "FAILURE"; });
    });
}

main() {
    testSimplifier();
    // println(simplifyAst(diffAst(infixToAst("(x + 5) ^ (x + 4) / (X ^ 2)"), "x")));
    // println(astToInfix(simplifyAst(diffAst(infixToAst("3 * x + 4 * x ^ 2 + x ^ 3"), "x"))));
    quit(0);
}
